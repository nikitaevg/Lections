200-600 циклов для доступа к памяти

Последовательное чтение круто, не последовательное херово

Если проц требует сначала одни 64кб потом другие потом третьи и все подряд, то он может предсказать что нам потребуется четвертая линейка.
гуглуить: prefetcher

PMU -- штука, которая считает сколько раз происходит какая-то хрень

architectural 6 штук примерно
non-architectural дофига 

не архитектурный - public интерфейс процессора
Сколько процессор простаивал
Обращения к кешу
Количество мисов
Сколько всего бранчей
Сколько бранч мисов
счетчики encore?

r412e -- архитектурный счетчик кеш миссов (видимо интел)

lfsr linear feedback shift register
https://tams-www.informatik.uni-hamburg.de/applets/hades/webdemos/35-selftest/30-lfsr/lfsr-8654.html
Генератор псевдослучайных битов
См. фото

Булевы схемы разбиваются DC-latch-ами
См. фото
Там они разделены ими на стадии и поэтому можно как конвейер сделать.
Типа умножение три такта но каждый такт можно давать 

Как делать предикты предиктивными.
Можно выполнять тот бранч который выполнялся в прошлый раз.
Код на первой фотке можно сделать без бранча
lfsr ^= lsb * 0xb400;
lfsr ^= 0x400 & -lsb;
Странно, но в первом варе всего 30000 мисов из 1е6
Gcc соптимизировал до функции cmovne которая возвращает либо первый либо второй вар

Без оптимизации 500000 мисов и 6.4 сек.
