Как компилировать ассемблер

.s -> .o -> a.out
   asm	 ld

Ассемблерные вставки

Команды, начинающиеся с точки -- директивы.
В ассемблере чтобы сделать метку глобальной надо написать директиву .global _f

Ассемблерные вставки. 
__asm__ выписывает в ассемблерный код то, что передадим.
Пример
__asm__("crc 32q\t" "(%1), %0") -- выписать команду crc 32q		(%1), %0  // (%1) - взять по адресу
crc -- способ посчитать какую-то хеш-функцию. В c и c++ нельзя достучаться до этой команды
__asm__("..." : "=r"(ret) : "r"(buf+i), "0"(ret));
"=r"(ret) -- у этой вставки один аутпут и записать его в ret. %0 теперь будет ссылаться на регистр, из которого потом запишет в ret
"r"(buff + i) -- положи в какой-нибудь регистр buf + i. Каждому r дается свой номер
"0"(ret) и положить в нулевой регистр ret

гуглить gcc extended asm
Считается, что регистры не в инпут и не в аутпут не должны меняться, иначе может что-нибудь испортиться.
есть clobbers -- какие портятся штуки
cc -- портим flags
memory -- портим память
Ассемблерные вставки можно оптимизировать, как и обычный код

еще пример
__asm__("divq %[v]" 
	: "=a" (result), "=d"(*r)
	: [v] "r"(v), "a"(u0), "d"(u1)
	);
=a -- возьми из rax 
=d -- возьми из rdx итд
a -- положи в rax

[v] "r"(v) -- положи в переменную [v] значение v
[v] -- название. %[v] -- взять по названию.
считается, что регистры только из аутпут и клобберс могут меняться

mov %%rdx -- экранирование %

Безымянные метки
i:
jmp ib; -- прыгнуть на i назад
jmp if; -- прыгнуть на i вперед

функции escape и clobber
void escape (void* p)
__asm__("" : : "g"(p) : "memory")

Служит для того, чтобы сказать компилятору что этот указатель может быть использован, чтобы не удалять мертвый код
Пример
std::vector<int> x();
for ()
	x.push_back(i)
если посчитать так время, компилятор удалит этот вектор, но если ескейпнуть его то он не будет ивейдиться


movntdq -- не читает кеш чтобы записывать в него, а записывает сразу в RAM, минуя кеш. Это удобно типа для memcpy 
чтобы не читать-записывать линейку кеша на запись кучу раз, а записывать бакетами сразу в память в RAM

