bash

#/bin/bash

Херовый язык
Но от него не убежать

Команды:
man
1 - системные утилиты
2 - системные вызовы
3 - библиотечные ...

Опции запуска
rm -rf dir

заархивировать файл "-cf"
tar -cf x.tar -- -cf // -- - заканчивает опции

>> output.txt -- добавить в файл, а не перезаписывать его

> - бинарный оператор то есть 2> перенаправить stderr в файл

0 - stdin
1 - stdout
2 - stderr

2 > &1 - не файл "1" а в файл с файловым дескриптором 1

g++ bad.cpp 2>&1 >dev/null это вывести stderr в stdout а stdout в dev/null, но stderr будет выводиться на экран

ls * покажет все файлы кроме скрытых

файл . - файл текущей директории
файл .. - файл родительской директории

Скрытые файлы никак не отличаются от обычных кроме того что начинаются с .

У программы есть переменные окружения
environ(7) getenv(3)

int main(int argc, char const *argv[], char ** envp) -- переменные окружения
{
	/* code */
	return 0;
}

Объявления переменных
export VAR =val; prog -- глобальная переменная
VAR=val prog -- только к переменным программы prog

Использование 
echo $HOME
PATH=$PATH:$HOME/bin:$HOME/.bin
Эти переменные -- обычные строки

"$HOME" -  путь к домашней директории.  Подставить значение переменной. То же что и "${HOME}"
'$HOME' - подставляют $HOME. см фото.

Арифметика
A=$((2+2))
echo $A

A=$((A+$A))
echo $A

Специальные переменные какие-то. Легче загуглить

Запуск нескольких Команды
подряд a;b;c
ленивое И a&&b&&c
ленивое ИЛИ a||b||c
берутся коды возврата return 0

Пайпы
a|b|c это склеивание вводов выводов программ Реализовано примерно как очередь

echo `pwd` -- сначала выполнится pwd потом будет вызван echo

& -- создать демона
wait ожидать завершения демона.

Как писать скрипты 

#!/bin/bash -- указание интерпретатора