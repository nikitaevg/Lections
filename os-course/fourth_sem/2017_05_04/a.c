Как все на самом деле!

Кольца защиты

0-3.
3 usermode наши программы
2
1 иногда драйвера
0 supervisor ядро
-1 hypervisor виртуализация 
hypervisor предоставляет интерфейс для виртуальных машин. Сами виртуалки работают в нулевом кольце.
Они не могут испортить ос, так как она работает через гипервизора.
-2 SMM(system management mode) железо, питание (биос работает где-то здесь)
-3 AMT администрирование (работает независимо от того, работает ли основной процессор)

Код пишется для третьего кольца
обсуждается 0-2 кольца
-1 для разработчиков виртуальных машин
-2 иногда сюда пускают простых смертных (coreboot)
-3 в понедельник все сломалось на всех интелах 2008-2017(((((((((((((( https://www.theregister.co.uk/2017/05/01/intel_amt_me_vulnerability/


Прерывания
Сигналы
	Железные
		данные считались
		таймер тикнул
	программные
		программа хочет внимания системы
		сисколы
	исключения
		деление на ноль
		page fault

real mode
	0x100 адресов по адресу 0 (байты 0 - 1024)
	Никакой доп информации

protected mode
	массив структур по адресу %idtr
	P - есть ли
	DPL - права

На macOs работает два ядра Mach и BSD. Это конечно кек

прилетело прерывание 
	Надо положить в стек регистры
		Кладем в стек ядра, так как пользовательский стек может указывать куда угодно (даже на код ядра)

	Hardware Multitasking
		TSS
			табличка с данными процесса
			адрес стека для прерываний

iret -- выход из обработчика (снимает из стека данные и возвращается обратно)

примеры прерываний
Division by zero
Breakpoint
General Protection Fault 
Page fault обращение не к той памяти
double fault при попытке запустить обработчик сломалось
triple fault перезагрузка

таймер позволяет рапределять процессорное время
Direct memory access - прерывание на конец записи чтения

Виртаульная память
mmu
Big pages
Минуя page table страница будет 4мб
Обращений к памяти меньше, не занимает 1024*1024 uint32_t
последние 12 бит GS0ADWURP
page Size -- Big pages или нет
Accessed -- было обращение
cache Disable
Write Through -- да или нет
User-accessible
RW
Present

PAE
32-х битные виртуальные адреса
64-битные физические адреса 

Было 32 = 10 + 10 + 12
1024 записи по 4 байта 
два уровня таблиц

Стало 32 = 2 + 9 + 9 + 12
512 записей по 8 байт
Три уровня таблиц
+NX бит -- бит можно ли исполнять

paging amd64
64 = 9 + 9 + 9 + 9 + 12 
	Page-map level 4
	page-directory pointer table
	page directory
	page table

Страницы 4К большие страницы 2М и очень большие страницы 1Г

TLB кеширует физические адреса. Не надо прыгать по mmu
invlplg или mov cr3
	бит G позволяет не удалять из TLB при перезаписи

page fault - обращение к памяти без бита P.

swap. 
	Выгружаем давно не использовавшуюся память на диск. 
	Accessed бит иногда сбрасывается в 0. И если он давно 0, то можно кинуть на диск.
	Летит page fault ядро смотрит в свопе и если он там есть, то страница загружает обратно.

Есть nonswappable (к примеру код загрузки в своп и из него)

Ленивое выделение страниц. Пусть просит 1Г. Отобразим сначала все page table в одну страницу заполненную нулями
Когда к ней обращаются на запись бросается page fault и только тогда выделяется память.
OOM killer
	Что если действительно закончилась память.
	В этом случае убиваем самое прожорливое приложение

fork COW

еще с помощью page fault можно юзать memory-mapped файлы. Лениво загружаем файлы в память, а не сразу

dirty-bit бит что данные поменялись

vdso 
	хотим еще более быстрые системные вызовы.
	К примеру текущее время.
	Пошарим страницу со временем между всеми процессами и будем просто обращаться к этой странице если надо
	pd и pt тьюринг полный ???. Вычисления за 0 инструкций. trapcc