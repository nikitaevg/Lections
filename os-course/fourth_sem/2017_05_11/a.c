Выделение памяти

new/delete 	
userspace
можно переопределять

malloc/free + calloc (зануляет память), realloc(выделяет память по указателю какого-то размера), (alloca -- выделить память на стеке)		
userspace
можно переопределить, но сложно

mmap/munmap		
kernelspace

sbrk 

wtf:
int main()
{
	int* p = malloc(sizeof(int));
	int* q = realloc(p, sizeof(int)); (старый инвалидируется)
	*p = 1;
	*q = 2;
	if (p == q)
		printf("%d % d\n", *p, *q);
	return 0;
}
выведется 1 2

память процесса:
стек
V

^
куча
данные 
код           херня

стек
V


куча
данные
код				см фото

Че хотим сделать:
Реализуем свой malloc free через mmap munmap
malloc должен любой размер страницы выделять, а mmap может выделять только целое число страниц 

SLAB

пусть данные фиксированного размера k
Суперблок 
	разбитый на куски по k
	+ список свободных ячеек
Проблема
	где хранить список свободных?
	что если они кончились
	как делать free

представляени суперблока:
сначала метаданные -- указатель на голову. В свободных будет указатель на следующий свободный.
Чтобы суперблок не кончался, сделаем много суперблоков и сделаем из них двусвязный список
Также будем хранить указатель на суперблок, из которого можно что-то выделить
И будем хранить указатель на двусвязный список заполненных суперблоков.
Если суперблок заполнился, добавляем его в заполненные

Как делать free? Ему дается только указатель и начало суперблока хер найдешь.
Давайте суперблоки будут выровнены на страницу, тогда узнать адрес начала просто.
см фото

Достоинства
	очень быстро O(1)
	маленьки overhead
недостатки
	фискированный размер

Free List Allocator

см фото
Пусть пользователь попросил 16 байт
Выделим 20 байт и первые четыре байта будут для метаданных

Первый пустой блок может не подойти по размеру
Делим блок на два один занимаем другой делаем свободным новым

Достоинства 
	работает для любых размеров 
Недостатки 
	работает
	фрагментация
Стратегии
	first-fit
	best-fit

Оптимальный аллокатор
SLAB для маленьких
Free list для средних
mmap для больших
Работает всегда, ура

Как делать free? Надо узнать каким способом порожден блок. Будем хранить несколько бит у каждой страницы

Другие способы:
Фиксируем X > 1 (X = 2)
Создаем SLAB для объектов размера m, mX, mX^2...
Округляем размер запроса вверх к ближайшему mX^i

Hoard аллокатор
	многопоточность
	Как решать? Давайте сделаем одну блокировку.

	False sharing
	Ответы близкие по времени лежат близко в памяти
	Вспомним кеши. Есть кеш-линии. 64 байта.
	Если 8 байт память требуем по времени близко, они будут в одной кеш-линии. 
		И когда один поток будет записывать, все данные будут записыватся в RAM, что совсем не нужно

	Можно еще выдавать каждому потоку свой набор суперблоков и иногда отдает.
	То есть когда один поток взял очень много суперблоков и сразу их освободил, то если не забирать, то будут проблемы


thread-local storage
Сегментная адресация
Адрес = База + Смещение
У потоков память общая, а хотим не общую
Сегмент %gs (32) или %fs(64)

Virtual Memory Areas
Ядру нужно обрабатывать mmap 
	"Найди X свободных страниц подряд"
Примерно как "Средний аллокатор"
	Дерево отрезков или дерево поиска