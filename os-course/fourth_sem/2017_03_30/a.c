Терминалы

Появились когда с компьютером появилась возможность взаимодействовать интерактивно

TeleTYpewriter телетайп.

Как работает:
Кнопки -> Провода -> UART -> драйвер UART -> драйвер TTY
обратно так же только вместо кнопок принтер. 

Чтобы редактировать ввод между драйвером UART и драйвером TTY появляется Line discipline
При нажатии Enter LD понимает что поступила новая порция данных

Передача данных по COM порту

Передается с частотой 9600 бит в секунду

Чтобы поддерживать синхронизацию сначала передается 0, потом 8 бит потом бит четности и потом всегда 1.

SENDER ======== RECIEVER
Они работают примерно на 9600 частоте. За 11 бит эти хреновины не рассинхронизируются
См. фото

screen /dev/ttyUSB0 some_speed -- подключиться по USB к терминалу

С помощью stty можно отрубить LD и к примеру cat будет обрабатывать символы сразу, без буффера

N_TTY - один из видом LD
PPP, Bluetooth, IrDa тоже LD, которые бьют данные на пакеты.

Там есть про демонов: https://www.kernel.org/doc/Documentation/serial/tty.txt

Драйверы TTY
/proc/tty/drivers

Можно реализовать свой терминал

ssh

Драйвер tty запущен локально, а надо взаимодействовать с удаленным компом

Похоже на pipe

Есть два FD: master и slave
Это два PTY -- псевдотерминала

Оба FD и на запись и на чтение.

К Slave могут подрубаться кто угодно типа vim, bash, master подключен к какому-то терминалу.
См. фото

Создание псевдотерминала

int posix_openpt(int flags) -- получить мастер конец псевдотерминала

Открыть файл /dev/ptmx и получить мастер-конец -- файл для создания нового псевдотерминала

int grantpt(int fd) 
slave соответсвует /dev/pty/5. Но на этот файл могут быть другие права. Этот файл надо как-то присвоить себе.
Функция grantpt делает это за нас. Почему-то ее необязательно вызывать сейчас, но надо по стандарту

int unlockpt(int fd);
Разблокирует файл, перед этим он был заблокирован (не совсем понял почему)

char *ptsname(int fd); full pathname to the slave device

Состояния процессов. См фото
Interruptable sleep - родитель еще не собрал этого ребенка, не закопал

^C = C ^ 0x40 -- ctrl+c которая прерывает процесс. На деле просто посылается сигнал соответствующий ^0x40

^C SIGINT
^\ SIGQUIT
^Z SIGTSTP (SIGSTOP)

^D -- завершить read
^D с нулевым буфером EOF
^S Останавливает вывод пока не заполнится буффер (Про буффер не уверен)
^U продолжить
SIGTTIN SIGTTOU (что-то)